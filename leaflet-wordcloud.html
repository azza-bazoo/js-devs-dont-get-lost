<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7.1/leaflet.css">

<style type="text/css">
  svg {
    position: relative;
    border: solid 1px blue;
  }
  #map {
    height: 750px;
  }
</style>

<body>

<div id="map"></div>


<script src="http://cdn.leafletjs.com/leaflet-0.7.1/leaflet.js"></script>
<script src="js/jquery-2.0.3.min.js"></script>
<script src="js/d3.v3.min.js"></script>
<script src="js/d3.layout.cloud.js"></script>
<script src="sydjs-words.js"></script>
<script>

$(function() {
  var fill = d3.scale.category10();

  var draw = function(word_data, svg_el) {
    svg_el
      .selectAll("text")
        .data(word_data)
      .enter().append("text")
        .style("font-size", function(d) { return d.size + "px"; })
        .style("font-family", "Impact, sans-serif")
        .style("fill", function(d, i) { return fill(i); })
        .attr("text-anchor", "middle")
        .attr("transform", function(d) {
          return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
        })
        .text(function(d) { return d.key; })
  }

  var layoutWords = function(wordset, i, fontScale) {
    var layout = d3.layout.cloud()
          .size([450, 450])
          .text(function(d) { return d.key; })
          .font("Impact")
          .fontSize(function(d) { return fontScale(+d.value); })
          .rotate(function(d) { return ~~(Math.random() * 4) * 45 - 90; })
          .padding(1)
          .on("end", function(word_data) {
            draw(word_data, g[i]);
          })
          .words(wordset)
          .start();
  }

  var stopwords = ["and", "the", "with", "for", "to", "of", "in", "from", "a", "can", "but", "get", "an", "so"];

  var wordsets = [];
  var max_count = 0;

  data.forEach(function(item) {
    var word_hash = {};
    item.words.forEach(function(word) {
      if (stopwords.indexOf(word) !== -1) {
        return;
      }

      if (word in word_hash) {
        word_hash[word] ++;
      } else {
        word_hash[word] = 1;
      }
    });

    var wordset = [];
    for (var word in word_hash) {
      wordset.push({ key: word, value: word_hash[word] });
      if (word_hash[word] > max_count) { max_count = word_hash[word]; }
    }

    wordsets.push(wordset);
  });


var map = new L.Map("map", {center: [-33.8691, 151.20538], zoom: 17})
    .addLayer(new L.TileLayer("http://{s}.tile.cloudmade.com/20431b4bbf9e4c3f90399422715b6fa0/998/256/{z}/{x}/{y}.png"));

var svg = d3.select(map.getPanes().overlayPane).append("svg");
var g = [];

// var transform = d3.geo.transform({point: projectPoint}),
//     path = d3.geo.path().projection(transform);



  // Reposition the SVG to cover the features.
  var resetSVG = function() {
    // Loosely based on http://bost.ocks.org/mike/leaflet/
    var topLeft = map.latLngToLayerPoint(mapTopLeft);
    var bottomRight = map.latLngToLayerPoint(mapBottomRight);

    var newWidth = bottomRight.x - topLeft.x;
    var xScale = newWidth / mapOriginalWidth;
    var newHeight = bottomRight.y - topLeft.y;
    var yScale = newHeight / mapOriginalHeight;
    
    var ctopleft = map.containerPointToLatLng(L.point(0,0));
    var ltopleft = map.latLngToLayerPoint(ctopleft);
    var cbottomright = map.containerPointToLatLng(L.point(mapOriginalWidth,mapOriginalHeight));
    var lbottomright = map.latLngToLayerPoint(cbottomright);

    // they normally should be equal?
    console.log(xScale, yScale);

    // svg .attr("width", newWidth)
    //     .attr("height", newHeight)
    svg .style("left", ltopleft.x + "px")
        .style("top", ltopleft.y + "px");

    for (var i = 0; i < g.length; i ++) {
      //translate(" + -topLeft.x + "," + -topLeft.y + ") 

    var word_centre = map.latLngToContainerPoint(new L.LatLng(data[i].lat, data[i].long));

      g[i].attr("transform", "scale(" + xScale + " " + yScale + ")translate(" + (word_centre.x / xScale) + "," + (word_centre.y / yScale) + ")");
    }

//    feature.attr("d", path);
  }


// var feature = g.selectAll("path")
//     .data(collection.features)
//   .enter().append("path");

map.on("moveend", resetSVG);
//resetSVG();


var mapTopLeft = map.layerPointToLatLng(L.point(0, 0));
var mapBottomRight = map.layerPointToLatLng(L.point(
  $("#map").width(),
  $("#map").height()
));

var mapOriginalWidth = $("#map").width();
var mapOriginalHeight = $("#map").height();

    //translate(" + -topLeft.x + "," + -topLeft.y + ") 

  var fontScale = d3.scale.log().range([5, max_count * 3]);
  wordsets.forEach(function(wordset, idx) {

    // var word_centre = map.latLngToLayerPoint(new L.LatLng(data[idx].lat, data[idx].long));

    g[idx] = svg.append("g")
              .attr("class", "leaflet-zoom-hide");
              // .attr("transform", "translate(" + word_centre.x + "," + word_centre.y + ")");

    layoutWords(wordset, idx, fontScale);
  });

resetSVG();

    svg .attr("width", mapOriginalWidth)
        .attr("height", mapOriginalHeight)
        .style("left", "0px")
        .style("top", "0px");


  // Use Leaflet to implement a D3 geometric transformation.
  // function projectPoint(x, y) {
  //   var point = map.latLngToLayerPoint(new L.LatLng(y, x));
  //   this.stream.point(point.x, point.y);
  // }

});

</script>
